package main

// Задание 11
// Реализовать пересечение двух неупорядоченных множеств.

import "fmt"

// intersection возвращает массив, включающий в себя все элементы, которые содержатся в обоих переданных массивах.
func intersection[T comparable](setA, setB []T) []T {
	result := make([]T, 0, len(setA))
	// преобразуем один из массивов в map
	mapB := make(map[T]bool)
	for _, item := range setB {
		mapB[item] = true
	}
	// перебираем все элементы оставшегося массива и ищем совпадения в мапе
	// благодаря устройству hash map доступ к её элементам осуществляется практически за константное время,
	// следовательно, мы получаем линейную сложность алгоритма
	for _, item := range setA {
		if mapB[item] {
			result = append(result, item)
		}
	}
	return result
}

func main() {
	// благодаря дженерикам наша функция работает с массивами любого comparable типа

	// целые числа:
	fmt.Println(intersection(
		[]int{2, 6, 8, 4, 12, 14, 10, 18, 12, 14, 16},
		[]int{21, 18, 15, 9, 12, 3, 6},
	))

	// дробные числа:
	fmt.Println(intersection(
		[]float32{-1.2, 5.6, 12.4, -12.4, -3.4},
		[]float32{12, 43, -22, 11, -1, 10},
	))

	// строки:
	fmt.Println(intersection(
		[]string{"рыба", "медуза", "кит", "акула", "краб", "кашалот", "осьминог", "каракатица", "кальмар", "дельфин", "креветка", "косатка"},
		[]string{"слон", "кошка", "дельфин", "собака", "кит", "хомяк", "волк", "кашалот", "корова", "козёл", "верблюд"},
	))
}
